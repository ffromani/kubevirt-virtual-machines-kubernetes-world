Kubevirt: bringing virtual machines in a Kubernetes world
And how golang made it possible and practical!
22 Oct 2019
Tags: containers,kubernetes,operator,management,golang

Francesco Romani
Sr Software Engineer, Red Hat
fromani at {gmail,redhat} dot com
http://github.com/{mojaves,fromanirh}

* whoami
- sweng @ Red Hat (but opinions and mistakes are my own!)
- works daily(-ish): kubernetes, golang, libvirt, kvm, python
- interested in: more golang, more containers, more kubernetes; lisp
- happy linux user (red hat linux, debian, ubuntu, fedora)

* Talk outline

1. what is kubevirt
2. how golang helps making kubevirt happen

* Part 1: what is kubevirt

* Virtual Machines

"A virtual machine (VM) is an emulation of a computer system. Virtual machines are based on computer architectures and provide functionality of a physical computer."

"[...] virtual machines [...] provide a substitute for a real machine. They provide functionality needed to execute entire operating systems."

"Modern hypervisors use hardware-assisted virtualization, virtualization-specific hardware, primarily from the host CPUs."

.link https://en.wikipedia.org/wiki/Virtual_machine source: wikipedia

That's QEMU+KVM(+virtio)

* Containers

A (Linux) container is a set of one or more processes isolated from the rest of the system, using facilities of the Linux kernel

.link https://en.wikipedia.org/wiki/List_of_Linux_containers source: not actual quote, amalgamation.

That's cgroups+seccomp+selinux+namespaces... All conveniently packed in a container runtime (cri-o, docker, rkt...)

* Containerized applications

A containerized application is the set of files needed to an application to run as container, packaged in a specific format (image).

.image images/Container_crane_and_MSC_Sola.jpg 400 _
.caption "Containers are being loaded on the container ship MSC Sola at the container terminal of Bremerhaven in Germany" by Tvabutzku1234, public domain, from Wikimedia Commons

* Kubernetes

Kubernetes (K8s) is an open-source system for automating deployment,  scaling, and management of containerized applications.

.image images/kube-flower.png
.caption image and quote taken from the [offical kubernetes documentation](https://kubernetes.io/)

* Virtual Machines vs Containers

* Kubevirt: bridging the gap!

KubeVirt is a virtual machine management add-on for Kubernetes, which allow users to run VMs right alongside containers in the their Kubernetes clusters.

.image images/kube_and_virt.svg

KubeVirt extends Kubernetes by adding resource types for VMs and sets of VMs through Kubernetesâ€™ Custom Resource Definitions API (CRD). KubeVirt VMs run within regular Kubernetes pods, where they have access to standard pod networking and storage, and can be managed using standard Kubernetes tools such as kubectl.

* Part 2: how golang helps making kubevirt happen

* Kubevirt, reprised

KubeVirt is a virtual machine management add-on for Kubernetes, which allow users to run VMs right alongside containers in the their Kubernetes clusters.

Where did golang help, and where didn't? (if it didn't)

Let's see, and let's discuss few challenges faced along the way.

* The usual suspects

Awesome features proven awesome once again

1. *fast* *compiler*
   helps making development smoother

2. *great* *builtin* *tools*
   unit tests (+ ginkgo/gomega), vet, lint, fmt...

3. *static* *linking* / *self-contained* *artifacts*
   make deployment easy and fast even in a containerized environments.
   They also help keeping the container image size small (well, small as possible).

* C interoperability

Two major players of the virtualizations ecosystems: 
.link https://libvirt.org libvirt
.link https://www.qemu.org QEMU

Both very mature, multi-million LOCs projects. Both written in C.

* C interoperability /2

Libvirt abstracts away (most of) the complexities of running QEMU
Kubevirt consumes the libvirt APIs[1]
Kubevirt needed interoperability with libvirt from day 0
Libvirt go bindings available from day 0, leveraging the C interoperability
Pure-golang bindings possible but riskier (less reuse of battle-tested code - maybe in the future?)

[1] in the 99% of the cases. In few corner cases, it talks with QEMU

* A few challenges faced along the way

We'll see now a couple of scenarios...

* challenge: validation

* challenge: validating objects

We have templates: "a template describes a set of objects that can be parameterized and processed to produce a list of objects for creation by the platform."

We want to validate the changes the user make to their templates - so we can detect incorrect or suboptimal/discouraged changes

* challenge: validating objects /2

We introduce validation rules.

The validation rules refer to the object fields.
The validation rules may involve comparing fields to other fields.
The validation rules express the involved fields using the JSONPath notation.

* challenge: validating objects /3

Kubevirt (but also others) objects have optional fields.

The JSONPath package adopted (from k8s) can't distinguish between optional field not being present and illegal JSONPath

* challenge: validating objects /3

Just send patches u/s?

Use the `reflect` package to recursively create all the optional fields for the objects being tested
Turns out it's easy:
.link https://github.com/fromanirh/kubevirt-template-validator/tree/master/pkg/kubevirtobjs 145 combined LOC

The two approaches fits nicely together

* challenge: monitoring

* challenge: the monitoring story

We want to report metrics about VM runtime behaviour

.link https://libvirt.org/html/libvirt-libvirt-domain.html#virConnectGetAllDomainStats libvirt provides a very nice API

It seems easy.

* challenge: the monitoring story /2

Kubevirt wants to use shared storage for the VM disks

Shared storage is essential to support live migration, a key feature of VM management

Shared storage may get unresponsive/blocked

Due to a longstanding issue of QEMU, if shared storage becomes unresponsive the libvirt API in turn becomes unresponsive

* challenge: the monitoring story /3

goroutines to the rescue!

Just use a throw-away goroutine for each VM to be monitored.
The goroutine will do a single round of monitoring, then will self-destroy.

.image images/gophercomplex2.jpg _ 600
.caption from "Concurrency is not Parallelism" - (C) Rob Pike 2012 - CC Attribution 3.0

* challenge: the monitoring story /4

This approach works very very nicely because goroutine are very cheap and managed by runtime

Avoids a lot of headaches managing an explicit thread pool (corner cases, tunables, refilling policies...)

* wrap-up

* takeaways

golang just fits in the kubevirt use case. How was it so smooth?

1. fit in the ecosystem / try hard to blend in
2. pick the right tool for the right job

* Q? A!

Questions?

Slides & more @ https://github.com/mojaves/
